name: Integration Tests

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types: [completed]
    branches: [main]
  pull_request:
    branches: [main]
    paths:
      - 'Projecto-Final/**'
      - 'docker-compose*.yml'
  workflow_dispatch:

permissions:
  contents: read

env:
  COMPOSE_PROJECT_NAME: mlops-integration-test

jobs:
  integration-tests:
    name: Full Stack Integration Tests
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create .env file
        working-directory: ./Projecto-Final
        run: |
          cat > .env << EOF
          # MinIO Configuration
          MINIO_ROOT_USER=admin
          MINIO_ROOT_PASSWORD=adminadmin
          
          # MLflow Database
          MLFLOW_DB=mlflow_db
          MLFLOW_DB_USER=mlflow_user
          MLFLOW_DB_PASSWORD=mlflow_pass
          MLFLOW_DB_NAME=mlflow_db
          
          # Raw Database
          RAW_DB=diabetic_raw
          RAW_USER=raw_user
          RAW_PASSWORD=raw_pass
          RAW_HOST=raw-db
          
          # Clean Database
          CLEAN_DB=diabetic_clean
          CLEAN_USER=clean_user
          CLEAN_PASSWORD=clean_pass
          CLEAN_HOST=clean-db
          
          # MLflow Configuration
          MLFLOW_S3_ENDPOINT_URL=http://minio:9000
          AWS_ACCESS_KEY_ID=admin
          AWS_SECRET_ACCESS_KEY=adminadmin
          
          # Airflow Configuration
          AIRFLOW_UID=50000
          AIRFLOW__CORE__EXECUTOR=LocalExecutor
          AIRFLOW__CORE__LOAD_EXAMPLES=False
          AIRFLOW_ADMIN_USER=admin
          AIRFLOW_ADMIN_PASSWORD=admin123
          AIRFLOW_ADMIN_EMAIL=admin@example.com
          EOF
          echo ".env file created"

      - name: Start Infrastructure Stack
        working-directory: ./Projecto-Final
        run: |
          echo "Starting infrastructure services..."
          docker compose up -d
          echo "Infrastructure stack started"

      - name: Check airflow-init status and logs
        working-directory: ./Projecto-Final
        run: |
          echo "Checking airflow-init status..."
          sleep 10
          
          # Wait for airflow-init to complete or fail
          MAX_WAIT=120
          ELAPSED=0
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(docker compose ps airflow-init 2>/dev/null | grep airflow-init | awk '{print $NF}' || echo "not found")
            
            if [ "$STATUS" = "Exited (0)" ]; then
              echo "‚úÖ airflow-init completed successfully"
              docker compose logs airflow-init
              break
            elif [ "$STATUS" = "Exited (1)" ]; then
              echo "‚ùå airflow-init failed with exit code 1"
              echo "üìã airflow-init logs:"
              docker compose logs airflow-init
              exit 1
            elif [ "$STATUS" != "not found" ] && [ "$STATUS" != "Up" ]; then
              echo "‚è≥ airflow-init status: $STATUS"
              break
            fi
            
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done
          
          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "‚ö†Ô∏è  Timeout waiting for airflow-init"
            echo "üìã airflow-init logs:"
            docker compose logs airflow-init || true
            echo "üìã airflow-init status:"
            docker compose ps airflow-init || true
          fi

      - name: Wait for services to be healthy
        working-directory: ./Projecto-Final
        run: |
          echo "Waiting for services to be healthy (timeout: 5 minutes)..."
          
          TIMEOUT=300
          ELAPSED=0
          INTERVAL=10
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            echo "Checking services health... (${ELAPSED}s/${TIMEOUT}s)"
            
            # Check MinIO
            if docker compose ps minio | grep -q "healthy"; then
              echo "‚úÖ MinIO is healthy"
            else
              echo "‚è≥ MinIO not ready yet"
            fi
            
            # Check MLflow DB
            if docker compose ps mlflow-db | grep -q "healthy"; then
              echo "‚úÖ MLflow DB is healthy"
            else
              echo "‚è≥ MLflow DB not ready yet"
            fi
            
            # Check Raw DB
            if docker compose ps raw-db | grep -q "healthy"; then
              echo "‚úÖ Raw DB is healthy"
            else
              echo "‚è≥ Raw DB not ready yet"
            fi
            
            # Check Clean DB
            if docker compose ps clean-db | grep -q "healthy"; then
              echo "‚úÖ Clean DB is healthy"
            else
              echo "‚è≥ Clean DB not ready yet"
            fi
            
            # Check Airflow DB
            if docker compose ps airflow-db | grep -q "healthy"; then
              echo "‚úÖ Airflow DB is healthy"
            else
              echo "‚è≥ Airflow DB not ready yet"
            fi
            
            # Check if all critical services are healthy
            if docker compose ps minio mlflow-db raw-db clean-db airflow-db | grep -q "healthy.*healthy.*healthy.*healthy.*healthy"; then
              echo "‚úÖ All infrastructure services are healthy!"
              break
            fi
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå Timeout waiting for services to be healthy"
            docker compose ps
            exit 1
          fi

      - name: Wait for MLflow to be ready
        working-directory: ./Projecto-Final
        run: |
          echo "Waiting for MLflow server to be ready..."
          TIMEOUT=120
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -f -s http://localhost:5000/health > /dev/null 2>&1; then
              echo "‚úÖ MLflow is ready"
              break
            fi
            echo "‚è≥ Waiting for MLflow... (${ELAPSED}s)"
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå MLflow did not become ready"
            docker compose logs mlflow
            exit 1
          fi

      - name: Wait for Airflow to be ready
        working-directory: ./Projecto-Final
        run: |
          echo "Waiting for Airflow webserver to be ready..."
          TIMEOUT=180
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -f -s http://localhost:8080/health > /dev/null 2>&1; then
              echo "‚úÖ Airflow is ready"
              break
            fi
            echo "‚è≥ Waiting for Airflow... (${ELAPSED}s)"
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ö†Ô∏è  Airflow may not be fully ready, but continuing..."
          fi

      - name: Test Database Connections
        working-directory: ./Projecto-Final
        run: |
          echo "Testing database connections..."
          
          # Test Raw DB
          echo "Testing Raw DB..."
          docker compose exec -T raw-db psql -U raw_user -d diabetic_raw -c "SELECT 1;" || exit 1
          echo "‚úÖ Raw DB connection successful"
          
          # Test Clean DB
          echo "Testing Clean DB..."
          docker compose exec -T clean-db psql -U clean_user -d diabetic_clean -c "SELECT 1;" || exit 1
          echo "‚úÖ Clean DB connection successful"
          
          # Test MLflow DB
          echo "Testing MLflow DB..."
          docker compose exec -T mlflow-db psql -U mlflow_user -d mlflow_db -c "SELECT 1;" || exit 1
          echo "‚úÖ MLflow DB connection successful"

      - name: Test MinIO Bucket
        working-directory: ./Projecto-Final
        run: |
          echo "Testing MinIO bucket..."
          
          # Check if bucket exists
          docker compose exec -T minio-mc mc ls minio/ || echo "MinIO MC container may have exited (this is normal)"
          
          # Test MinIO health
          if curl -f -s http://localhost:9000/minio/health/ready > /dev/null; then
            echo "‚úÖ MinIO is accessible and healthy"
          else
            echo "‚ùå MinIO health check failed"
            exit 1
          fi

      - name: Test MLflow API
        working-directory: ./Projecto-Final
        run: |
          echo "Testing MLflow API..."
          
          # Test health endpoint
          if curl -f -s http://localhost:5000/health > /dev/null; then
            echo "‚úÖ MLflow health endpoint is accessible"
          else
            echo "‚ùå MLflow health check failed"
            exit 1
          fi
          
          # Test API version
          VERSION=$(curl -s http://localhost:5000/api/2.0/mlflow/version | jq -r '.version' || echo "unknown")
          echo "MLflow version: $VERSION"
          
          # List experiments
          EXPERIMENTS=$(curl -s http://localhost:5000/api/2.0/mlflow/experiments/search | jq -r '.experiments | length' || echo "0")
          echo "Number of experiments: $EXPERIMENTS"

      - name: Test Airflow UI
        working-directory: ./Projecto-Final
        run: |
          echo "Testing Airflow UI..."
          
          # Test if Airflow webserver is accessible
          if curl -f -s http://localhost:8080/health > /dev/null; then
            echo "‚úÖ Airflow webserver is accessible"
          else
            echo "‚ö†Ô∏è  Airflow health endpoint not available, trying main page..."
            if curl -f -s http://localhost:8080 > /dev/null; then
              echo "‚úÖ Airflow UI is accessible"
            else
              echo "‚ùå Airflow UI is not accessible"
              exit 1
            fi
          fi

      - name: Start Applications Stack
        working-directory: ./Projecto-Final
        run: |
          echo "Starting applications stack..."
          docker compose -f docker-compose.apps.yml up -d
          echo "Applications stack started"

      - name: Wait for API to be ready
        working-directory: ./Projecto-Final
        run: |
          echo "Waiting for API to be ready..."
          TIMEOUT=120
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -f -s http://localhost:8000/health > /dev/null 2>&1; then
              echo "‚úÖ API is ready"
              break
            fi
            echo "‚è≥ Waiting for API... (${ELAPSED}s)"
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå API did not become ready"
            docker compose -f docker-compose.apps.yml logs api
            exit 1
          fi

      - name: Wait for Streamlit to be ready
        working-directory: ./Projecto-Final
        run: |
          echo "Waiting for Streamlit to be ready..."
          TIMEOUT=60
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -f -s http://localhost:8501 > /dev/null 2>&1; then
              echo "‚úÖ Streamlit is ready"
              break
            fi
            echo "‚è≥ Waiting for Streamlit... (${ELAPSED}s)"
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå Streamlit did not become ready"
            docker compose -f docker-compose.apps.yml logs streamlit
            exit 1
          fi

      - name: Test API Endpoints
        working-directory: ./Projecto-Final
        run: |
          echo "Testing API endpoints..."
          
          # Test /health
          echo "Testing /health endpoint..."
          RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:8000/health)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ /health returned 200"
          else
            echo "‚ùå /health returned $HTTP_CODE"
            exit 1
          fi
          
          # Test /model-info
          echo "Testing /model-info endpoint..."
          RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:8000/model-info)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ /model-info returned 200"
            echo "$RESPONSE" | head -n -1
          else
            echo "‚ö†Ô∏è  /model-info returned $HTTP_CODE (may not have model deployed yet)"
          fi
          
          # Test /predict
          echo "Testing /predict endpoint..."
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST http://localhost:8000/predict \
            -H "Content-Type: application/json" \
            -d '{
              "race": "Caucasian",
              "gender": "Female",
              "age_bucket": "[70-80)",
              "time_in_hospital": 3,
              "num_lab_procedures": 41,
              "num_procedures": 0,
              "num_medications": 11,
              "number_outpatient": 0,
              "number_emergency": 0,
              "number_inpatient": 0,
              "number_diagnoses": 6,
              "max_glu_serum": "None",
              "a1c_result": "None",
              "insulin": "Steady",
              "change_med": true,
              "diabetes_med": true,
              "diag_1": "428",
              "diag_2": "250.01",
              "diag_3": "401",
              "medical_specialty": "Cardiology",
              "admission_type_id": 1,
              "discharge_disposition_id": 1,
              "admission_source_id": 7
            }')
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ /predict returned 200"
            echo "$RESPONSE" | head -n -1
          else
            echo "‚ö†Ô∏è  /predict returned $HTTP_CODE (may not have model deployed yet)"
          fi
          
          # Test /metrics
          echo "Testing /metrics endpoint..."
          RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:8000/metrics)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ /metrics returned 200"
          else
            echo "‚ùå /metrics returned $HTTP_CODE"
            exit 1
          fi

      - name: Test Streamlit UI
        working-directory: ./Projecto-Final
        run: |
          echo "Testing Streamlit UI..."
          
          # Test main page
          if curl -f -s http://localhost:8501 > /dev/null; then
            echo "‚úÖ Streamlit UI is accessible"
          else
            echo "‚ùå Streamlit UI is not accessible"
            exit 1
          fi
          
          # Test health endpoint if available
          if curl -f -s http://localhost:8501/_stcore/health > /dev/null 2>&1; then
            echo "‚úÖ Streamlit health check passed"
          else
            echo "‚ö†Ô∏è  Streamlit health endpoint not available, but UI is accessible"
          fi

      - name: Test E2E Prediction Flow
        working-directory: ./Projecto-Final
        run: |
          echo "Running E2E test: Full prediction workflow..."
          
          # Step 1: Check API health
          echo "Step 1: Checking API health..."
          API_HEALTH=$(curl -s http://localhost:8000/health)
          if echo "$API_HEALTH" | grep -q "healthy\|ok"; then
            echo "‚úÖ API is healthy"
          else
            echo "‚ùå API health check failed"
            exit 1
          fi
          
          # Step 2: Get model info
          echo "Step 2: Getting model info..."
          MODEL_INFO=$(curl -s http://localhost:8000/model-info)
          if echo "$MODEL_INFO" | grep -q "model_name\|version"; then
            echo "‚úÖ Model info retrieved"
          else
            echo "‚ö†Ô∏è  Model info not available (model may not be deployed yet)"
          fi
          
          # Step 3: Make prediction
          echo "Step 3: Making prediction..."
          PREDICTION=$(curl -s -X POST http://localhost:8000/predict \
            -H "Content-Type: application/json" \
            -d '{
              "race": "Caucasian",
              "gender": "Female",
              "age_bucket": "[70-80)",
              "time_in_hospital": 3,
              "num_lab_procedures": 41,
              "num_procedures": 0,
              "num_medications": 11,
              "number_outpatient": 0,
              "number_emergency": 0,
              "number_inpatient": 0,
              "number_diagnoses": 6,
              "max_glu_serum": "None",
              "a1c_result": "None",
              "insulin": "Steady",
              "change_med": true,
              "diabetes_med": true,
              "diag_1": "428",
              "diag_2": "250.01",
              "diag_3": "401",
              "medical_specialty": "Cardiology",
              "admission_type_id": 1,
              "discharge_disposition_id": 1,
              "admission_source_id": 7
            }')
          
          if echo "$PREDICTION" | grep -q "prediction\|probability"; then
            echo "‚úÖ Prediction successful"
            echo "$PREDICTION"
          else
            echo "‚ö†Ô∏è  Prediction may have failed (model may not be deployed)"
            echo "$PREDICTION"
          fi
          
          # Step 4: Verify Streamlit is accessible
          echo "Step 4: Verifying Streamlit UI..."
          if curl -f -s http://localhost:8501 > /dev/null; then
            echo "‚úÖ Streamlit UI is accessible"
          else
            echo "‚ùå Streamlit UI check failed"
            exit 1
          fi
          
          echo "‚úÖ E2E test completed"

      - name: Performance Test
        working-directory: ./Projecto-Final
        run: |
          echo "Running performance test: 10 requests to /predict endpoint..."
          
          # Install bc for calculations
          sudo apt-get update && sudo apt-get install -y bc
          
          TOTAL_TIME=0
          SUCCESS_COUNT=0
          FAIL_COUNT=0
          
          for i in {1..10}; do
            echo "Request $i/10..."
            START_TIME=$(date +%s.%N)
            
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST http://localhost:8000/predict \
              -H "Content-Type: application/json" \
              -d '{
                "race": "Caucasian",
                "gender": "Female",
                "age_bucket": "[70-80)",
                "time_in_hospital": 3,
                "num_lab_procedures": 41,
                "num_procedures": 0,
                "num_medications": 11,
                "number_outpatient": 0,
                "number_emergency": 0,
                "number_inpatient": 0,
                "number_diagnoses": 6,
                "max_glu_serum": "None",
                "a1c_result": "None",
                "insulin": "Steady",
                "change_med": true,
                "diabetes_med": true,
                "diag_1": "428",
                "diag_2": "250.01",
                "diag_3": "401",
                "medical_specialty": "Cardiology",
                "admission_type_id": 1,
                "discharge_disposition_id": 1,
                "admission_source_id": 7
              }')
            
            END_TIME=$(date +%s.%N)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            ELAPSED=$(echo "$END_TIME - $START_TIME" | bc)
            
            if [ "$HTTP_CODE" = "200" ]; then
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              TOTAL_TIME=$(echo "$TOTAL_TIME + $ELAPSED" | bc)
              echo "  ‚úÖ Request $i: ${ELAPSED}s"
            else
              FAIL_COUNT=$((FAIL_COUNT + 1))
              echo "  ‚ö†Ô∏è  Request $i: HTTP $HTTP_CODE (may not have model)"
            fi
          done
          
          if [ $SUCCESS_COUNT -gt 0 ]; then
            AVG_TIME=$(echo "scale=3; $TOTAL_TIME / $SUCCESS_COUNT" | bc)
            echo ""
            echo "Performance Results:"
            echo "  Successful requests: $SUCCESS_COUNT/10"
            echo "  Failed requests: $FAIL_COUNT/10"
            echo "  Average response time: ${AVG_TIME}s"
            
            # Performance criteria
            if (( $(echo "$AVG_TIME < 1" | bc -l) )); then
              echo "  Status: ‚úÖ Good (< 1s)"
            elif (( $(echo "$AVG_TIME <= 3" | bc -l) )); then
              echo "  Status: ‚ö†Ô∏è  Acceptable (1-3s)"
            else
              echo "  Status: ‚ö†Ô∏è  Slow (> 3s) but acceptable for integration test"
            fi
          else
            echo "‚ö†Ô∏è  All requests failed (model may not be deployed yet)"
          fi

      - name: Collect logs on failure
        if: failure()
        working-directory: ./Projecto-Final
        run: |
          echo "Collecting logs from failed services..."
          mkdir -p logs
          
          docker compose logs > logs/infrastructure.log 2>&1 || true
          docker compose -f docker-compose.apps.yml logs > logs/applications.log 2>&1 || true
          
          echo "Logs collected"

      - name: Upload logs as artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-logs
          path: Projecto-Final/logs/
          retention-days: 7

      - name: Cleanup
        if: always()
        working-directory: ./Projecto-Final
        run: |
          echo "Cleaning up all services..."
          
          # Stop applications
          docker compose -f docker-compose.apps.yml down -v || true
          
          # Stop infrastructure
          docker compose down -v || true
          
          # Remove any orphaned containers
          docker ps -aq --filter "name=mlops-integration-test" | xargs -r docker rm -f || true
          
          # Clean up volumes
          docker volume ls -q --filter "name=mlops-integration-test" | xargs -r docker volume rm || true
          
          echo "‚úÖ Cleanup completed"

  generate-report:
    name: Generate Test Report
    runs-on: ubuntu-latest
    needs: [integration-tests]
    if: always()
    steps:
      - name: Generate comprehensive report
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Integration Tests Report
          
          ## Test Results Summary
          
          | Test Suite | Status |
          |------------|--------|
          | Full Stack Integration | ${{ needs.integration-tests.result == 'success' && '‚úÖ Pass' || '‚ùå Fail' }} |
          
          ## Services Tested
          
          - ‚úÖ Infrastructure Stack (MinIO, MLflow, Airflow, Databases)
          - ‚úÖ Applications Stack (API, Streamlit)
          - ‚úÖ Database Connections (Raw, Clean, MLflow)
          - ‚úÖ API Endpoints (/health, /model-info, /predict, /metrics)
          - ‚úÖ Streamlit UI
          - ‚úÖ E2E Prediction Flow
          - ‚úÖ Performance Testing
          
          ## Overall Status
          
          ${{ needs.integration-tests.result == 'success' && '‚úÖ **All integration tests passed!**' || '‚ùå **Some tests failed. Check logs in artifacts.**' }}
          
          ---
          
          *Report generated automatically after integration tests*
          EOF
